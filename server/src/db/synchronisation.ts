import { Table } from "drizzle-orm";
import { dbClient } from "../index";
import { upvotesTable, postsTable, usersTable } from "./schema";

export async function syncAllData(
  src: typeof dbClient,
  target: typeof dbClient
): Promise<undefined> {
  // Create the "users" table
  // Create the "users" table
  await target.execute(`
  CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR NOT NULL,
    email VARCHAR NOT NULL UNIQUE,
    password VARCHAR NOT NULL
  );
`);

  // Create the "posts" table
  await target.execute(`
  CREATE TABLE IF NOT EXISTS posts (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    animal VARCHAR(255) NOT NULL,
    notes VARCHAR,
    conservation_notes TEXT NOT NULL,
    image_url VARCHAR NOT NULL,
    latitude DOUBLE PRECISION NOT NULL,
    longitude DOUBLE PRECISION NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
  );
`);

  // Create the "upvotes" table
  await target.execute(`
  CREATE TABLE IF NOT EXISTS upvotes (
    id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    post_id INTEGER NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
    user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE
  );
`);

  await target.execute(`
    TRUNCATE TABLE upvotes, posts, users RESTART IDENTITY CASCADE;
  `);

  let schema = [usersTable, postsTable, upvotesTable];

  try {
    console.info("(DB JOB) Starting full sync...\n");

    for (const [tableName, table] of Object.entries(schema)) {
      const data = await src.select().from(table);

      if (data.length > 0) {
        await target.insert(table).values(data);
      }
    }

    console.info("(DB JOB) Database sync complete.");
  } catch (error) {
    console.error("Error during DB synchronization:", error);
  }
}

export async function checkDataDBs(
  primary: typeof dbClient,
  replica: typeof dbClient
): Promise<void> {
  await syncTable(usersTable, ["email"], primary, replica);
  await syncTable(postsTable, ["id"], primary, replica);
  await syncTable(upvotesTable, ["id"], primary, replica);
}

async function syncTable(
  table: Table,
  uniqueKeys: (keyof Table["_"]["columns"])[],
  primary: typeof dbClient,
  replica: typeof dbClient
) {
  const [primaryRows, replicaRows] = await Promise.all([
    primary.select().from(table),
    replica.select().from(table),
  ]);

  const uniqueKey = (row: any) => uniqueKeys.map((k) => row[k]).join("|");

  const pMap = new Map(primaryRows.map((row) => [uniqueKey(row), row]));
  const rMap1 = new Map(replicaRows.map((row) => [uniqueKey(row), row]));

  if (mapsAreEqual(pMap, rMap1)) {
    console.info(`(DB JOB) DB1 and DB2 are already in sync.`);
    return;
  }

  // Rows missing in target
  for (const [key, row] of pMap.entries()) {
    if (!rMap1.has(key)) {
      await replica.insert(table).values(row);
    }
  }

  // Rows missing in source
  for (const [key, row] of rMap1.entries()) {
    if (!pMap.has(key)) {
      await primary.insert(table).values(row);
    }
  }
}

// check if tables are equal already
function mapsAreEqual(map1: Map<string, any>, map2: Map<string, any>): boolean {
  if (map1.size !== map2.size) return false;
  for (const [key, val1] of map1) {
    const val2 = map2.get(key);
    if (!val2 || JSON.stringify(val1) !== JSON.stringify(val2)) {
      return false;
    }
  }
  return true;
}
